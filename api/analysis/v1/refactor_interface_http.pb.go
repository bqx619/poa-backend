// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.0.3

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type RefactorInterfaceHTTPServer interface {
	GetRefactor(context.Context, *GetRefactorRequest) (*GetRefactorReply, error)
	ListRefactor(context.Context, *ListRefactorRequest) (*ListRefactorReply, error)
	RecapRefactor(context.Context, *RecapRefactorRequest) (*RecapRefactorReply, error)
	RunRefactor(context.Context, *RunRefactorRequest) (*RunRefactorReply, error)
}

func RegisterRefactorInterfaceHTTPServer(s *http.Server, srv RefactorInterfaceHTTPServer) {
	r := s.Route("/")
	r.GET("/refactor/v1/survey", _RefactorInterface_RecapRefactor0_HTTP_Handler(srv))
	r.GET("/refactor/v1/{id}", _RefactorInterface_GetRefactor0_HTTP_Handler(srv))
	r.GET("/refactor/v1", _RefactorInterface_ListRefactor0_HTTP_Handler(srv))
	r.PUT("/refactor/v1/run", _RefactorInterface_RunRefactor0_HTTP_Handler(srv))
}

func _RefactorInterface_RecapRefactor0_HTTP_Handler(srv RefactorInterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RecapRefactorRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.refactor.v1.RefactorInterface/RecapRefactor")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RecapRefactor(ctx, req.(*RecapRefactorRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RecapRefactorReply)
		return ctx.Result(200, reply)
	}
}

func _RefactorInterface_GetRefactor0_HTTP_Handler(srv RefactorInterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetRefactorRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.refactor.v1.RefactorInterface/GetRefactor")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetRefactor(ctx, req.(*GetRefactorRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetRefactorReply)
		return ctx.Result(200, reply)
	}
}

func _RefactorInterface_ListRefactor0_HTTP_Handler(srv RefactorInterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListRefactorRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.refactor.v1.RefactorInterface/ListRefactor")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListRefactor(ctx, req.(*ListRefactorRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListRefactorReply)
		return ctx.Result(200, reply)
	}
}

func _RefactorInterface_RunRefactor0_HTTP_Handler(srv RefactorInterfaceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RunRefactorRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.refactor.v1.RefactorInterface/RunRefactor")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RunRefactor(ctx, req.(*RunRefactorRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RunRefactorReply)
		return ctx.Result(200, reply)
	}
}

type RefactorInterfaceHTTPClient interface {
	GetRefactor(ctx context.Context, req *GetRefactorRequest, opts ...http.CallOption) (rsp *GetRefactorReply, err error)
	ListRefactor(ctx context.Context, req *ListRefactorRequest, opts ...http.CallOption) (rsp *ListRefactorReply, err error)
	RecapRefactor(ctx context.Context, req *RecapRefactorRequest, opts ...http.CallOption) (rsp *RecapRefactorReply, err error)
	RunRefactor(ctx context.Context, req *RunRefactorRequest, opts ...http.CallOption) (rsp *RunRefactorReply, err error)
}

type RefactorInterfaceHTTPClientImpl struct {
	cc *http.Client
}

func NewRefactorInterfaceHTTPClient(client *http.Client) RefactorInterfaceHTTPClient {
	return &RefactorInterfaceHTTPClientImpl{client}
}

func (c *RefactorInterfaceHTTPClientImpl) GetRefactor(ctx context.Context, in *GetRefactorRequest, opts ...http.CallOption) (*GetRefactorReply, error) {
	var out GetRefactorReply
	pattern := "/refactor/v1/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.refactor.v1.RefactorInterface/GetRefactor"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *RefactorInterfaceHTTPClientImpl) ListRefactor(ctx context.Context, in *ListRefactorRequest, opts ...http.CallOption) (*ListRefactorReply, error) {
	var out ListRefactorReply
	pattern := "/refactor/v1"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.refactor.v1.RefactorInterface/ListRefactor"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *RefactorInterfaceHTTPClientImpl) RecapRefactor(ctx context.Context, in *RecapRefactorRequest, opts ...http.CallOption) (*RecapRefactorReply, error) {
	var out RecapRefactorReply
	pattern := "/refactor/v1/survey"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.refactor.v1.RefactorInterface/RecapRefactor"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *RefactorInterfaceHTTPClientImpl) RunRefactor(ctx context.Context, in *RunRefactorRequest, opts ...http.CallOption) (*RunRefactorReply, error) {
	var out RunRefactorReply
	pattern := "/refactor/v1/run"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.refactor.v1.RefactorInterface/RunRefactor"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
